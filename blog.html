<!DOCTYPE html>
<head>
<style>
    .short-divider{
        max-width: 500px;
        min-width: 100px;
        height: 1px;
        border: solid 1px black;
    }
    .text-column{
        max-width: 700px;
    }
    .code-block{
        background-color: #ccc;
        max-width: 700px;
        padding: 20px;
        border: black solid 2px;
    }
    h3{
        text-decoration: underline;
    }
</style>
</head>

<body>
    <div id = "post-content">
        <h2>My Adventures with AES</h2>
        <div class = "short-divider"></div>
        <h5>My experiences writing a ground-up implementation of the Advanced Encryption Standard in Dart.</h5>
        <p class = "text-column">
            The AES is a commonly used encryption standard which was adopted by the United States Government following a NIST competition.
            Its predecessor, DES or the Digital Encryption Standard, had been shown to be vulnerable to several types of attacks and a complete
            crack of the DES cipher was considered imminent. The cipher which won the NIST competition to become the AES was the Rijndael cipher.
            Designed by two Belgian cryptographers, Vincent Rijmen and Joan Daemen, the Rijndael cipher won out over fifteen serious competitors
            which also met the NIST requirements for entry.  After being ratified by NIST it was accepted by the US Government in 2002 as a federal
            standard.
        </p>
        <br>
        <h3>A High-Level Overview</h3>
        <p class = "text-column">
            AES works by applying a repetitive process to a block of 128 bits of data. This process allows the data to be diffused sufficiently far
            from its original state as well as encrypted multiple times using multiple keys (referred to as round keys in the cipher). Typically the
            process starts by obtaining 128, 192 or 256 bits of secure random data from an SPRNG which are used as the private key of the encryption.
            The key is then subjected to a process known as key expansion where the original key is used to generate 10, 12 or 14 round keys depending
            on the length of the private key.  Once these keys are derived the actual encryption begins.
        </p>
        <p class = "text-column">
            First the private key is applied to the current block (I will go over what "applied" entails later), this comprises the complete first
            round of encryption.  Next the block undergoes three processes to diffuse the data, 1) Substitute bytes, 2) Shift rows, 3) Mix columns;
            after these three processes complete the next round key is applied and the cycle begins again. This cycle occurs a total of 9, 11 or 13
            times depending on the key size. Finally, for the last round, the substitute bytes and shift rows steps occur before the final
            round key is applied.  Note that the mix columns step is omitted in the final round.  Once the first block of 128 bits is encrypted subsequent
            blocks are encrypted the same way.  If the total number of bits to be encrypted cannot be broken evenly into 128 bit blocks the last block is 
            padded with zeros.
        </p>
        <br>
        <h3>A Few Notes</h3>
        <ol>
            <li class = "text-column">
                I am not a cryptographer, the following information is my understanding of the AES and may be incorrect. I suggest that you check this
                information against other sources if you are trying to learn about AES beyond simple curiosity.
            </li>
            <li class = "text-column">
                This post contains my code implementing AES, the code can also be found <a href = "https://github.com/ixonstater/learning_aes">here</a>
                on my github page. This code should NOT be used ANYWHERE unless you are trying to learn about AES. While the AES has never been cracked,
                untested implementations are often vulnerable to a group of exploits known as side-channel attacks.
            </li>
            <li class = "text-column">
                My implementation of AES does not use a secure cipher mode, instead it uses the "default" AES encryption mode ECB or Electronic Code Book.
                I will not cover different cipher modes in depth here as they do not affect the base AES algorithm, but you should note that using an
                insecure cipher mode can also leave your information in a vulnerable state post encryption.
            </li>
        </ol>
        <br>
        <h3>Fundamental Mathematics in the AES</h3>
        <h4>Bitwise Xor</h4>
        <p class = "text-column">
            Xor is the logic gate that AES uses to apply round keys to pieces of data. Xor works well for this because each possible output is distributed
            evenly among the possible inputs. That is, an output of 1 and an output of 0 both have two distinct inputs that can produce them. If an and gate
            or a normal or gate were used an output of 0 or 1 depending on which was used could be translated directly to the given inputs. An Xor truth
            table looks like this:
        </p>
        <pre class = "code-block">
A_______B___|___C
0       0   |   0
0       1   |   1
1       0   |   1
1       1   |   0
        </pre>
        <p class = "text-column">
            A bitwise Xor works by applying the Xor operator across each bit in two corresponding bit sets. For example, 010101 and 110011
            <br>010101
            <br>110011
            <br>______
            <br>100110
        </p>
        <h4>Galois Fields</h4>
        <p class = "text-column">
            Probably the single most important set of operations in AES encryption are those involving Galois Fields. Evariste Galois, pronounced Galwaa,
            was a brilliant French mathematician who died very young after being wounded in a duel. His work in finite fields is crucial to the Rijndael
            cipher and AES. A finite field (also known as a Galois field) is a field that contains a finite (limited / constrained) number of elements. Essentially it is a series of
            integers starting at x and ending at x + i where i is the length of the field. The finite field is maintained by defining numeric operations eg.
            addition and multiplication such that any operation applied to members of the field will produce another number in the field. For example in
            Gf(5) (denoting the field {0, 1, 2, 3, 4}), 1 + 2 = 3, but 4 + 1 = 0. This type of operation should be familiar to anyone with experience
            using the modulus operator. Indeed, for any prime limit eg Gf(3), Gf(19), Gf(13), addition and multiplication can be defined as c = (a + b) % i
            and c = (a * b) % i where i is the limit of the Galois field.
        </p>
        <p class = "text-column">
            Addition and multiplication in prime Galois fields are simple enough, but what about Gf(6) or Gf(8)? As it turns out one of these will work but
            the other will not; not just any number can be chosen as the limit of a finite field without breaking the constraints on arithmetic operations. 
            The number chosen must be either a prime, or a prime power.  A prime power is a number of the form p^k where k is an arbitrary exponent and p
            is an arbitrary prime number. If these constraints are followed a finite / Galois field can be constructed, albeit with different rules involving
            multiplication and addition.
        </p>
        <p class = "text-column">
            It is helpful to understand a little about the representation of numbers in a Galois field as polynomials with coefficients in Gf(2). Remember
            that Gf(2) = {0, 1}, so the possible coefficients in our polynomial are either 0 or 1. This lets us represent any number in any Galois field
            Gf(p^k) as a polynomial where the coefficient is the binary digit occupying that space.  For example 41 = 00101001 = 0x^7 + 0x^6 + 1x^5 + 0x^4
            + 1x^3 + 0x^2 + 0x^1 + 1x^0 = x^5 + x^3 + 1. This representation may seem convoluted, but it is necessary to preform addition and multiplication
            in a prime power Galois field. Galois operations can be done with any prime base, however base 2 is most popular in computer applications because
            of the numbers binary nature.
        </p>
        <p class = "text-column">
            Addition is done by adding two numbers (represented as polynomials) from Gf(p^k) in Gf(p). For example 
            <br>41 + 10 in Gf(256)
            <br>= (x^5 + x^3 + 1) + (x^3 + x)
            <br>= x^5 + x + 1.
            <br>Remember, we are adding in Gf(2) which is the prime base of 256 so 1 + 1 = 0; this is the reason that x^3 + x^3 results in 0. This is 
            more easily understood in its binary representation 1010 + 101001 where addition is actually a bitwise Xor operation. The Xor trick only works
            for Galois fields of base 2 or having a characteristic of 2. Lucky for us AES uses Galois(256) for its operations so the Xor trick is
            applicable.
        </p>
        <p class = "text-column">
            Multiplication is more complex than addition and is done by standard polynomial multiplication followed by modular division via some irreducible polynomial which
            was used define the finite field.  Sounds hard right? It's not too bad if taken one step at a time with an example, so, for example: 12 * 7 in Gf(2^8).
            <br>12 = x^3 + x^2 (see description of number representation as polynomials in Galois fields above)
            <br>7 = x^2 + x + 1
            <br>p = (12 * 7)
            <br>p = (x^3 + x^2) * (x^2 + x + 1)
            <br>p = (x^5 + x^4 + x^3) + (x^4 + x^3 + x^2).
            <br>So far we have just done simple polynomial multiplication; in the next step, consolidating the terms, addition is done like described above, in Gf(2). Therefore
            our polynomial product 
            <br>p = x^5 + x^2 = 36.
            <br>Since this does not exceed the limit of our our field, 256, the final step of reducing modulo some
            irreducible polynomial is not necessary and our final product is 36. It is worth noting that with the reducing polynomial for AES, applying the
            modulus operation would still result in 36 being the final answer. If you want to see an example involving modulo reduction please look
            <a href = "https://en.wikipedia.org/wiki/Finite_field_arithmetic">here</a>.
        </p>
        <p class = "text-column">
            For practical application in AES multiplication is usually done via lookup in a table of values rather than via a computational process (unless
            the implementation is built in a context with very low memory availability). This method requires 256 bytes of total memory space. In addition,
            Galois multiplication in 2^8 (the field size used in AES) can be done very efficiently using a modified version of the 
            <a href = "https://en.wikipedia.org/wiki/Finite_field_arithmetic">Peasant's Algorithm</a>. Included here is a dart function which implements that
            algorithm.
        </p>
        <pre class = "code-block">
int galoisMultiplication(int a, int b) {
    int p = 0;
    int highBitSet;
    for (var i = 0; i < 8; i++) {
        if ((b & 1) == 1) {
        p ^= a;
        }
        highBitSet = (a & 0x80);
        a <<= 1;
        if (highBitSet == 0x80) {
        a ^= 0x1b;
        }
        b >>= 1;
    }

    // Convert back to unsigned 8 bit int
    return p % this._fieldLimit;
}
        </pre>
        <h3>Sbox Generation</h3>
        <p class = "text-column">
            A key piece of Rijndael ciphers is the byte substitution box. At each encryption step, excluding the first round, and during key expansion the
            byte substitution box, or Sbox, is used to exchange one byte (eight bits) for another. The Rijndael algorithm does not use a dynamically generated
            Sbox, but rather has a well defined method for generating the same Sbox each time. The Sbox is arranged so that a particular byte can be located
            with its 4 most significant bits (largest bits) determining the column and its 4 least significant bits determining the row. The procedure for 
            generating the Sbox can be broken into two distinct steps, first each number from 0 - 255 has its multiplicative inverse calculated in Gf(2^8),
            second each of the multiplicative inverses has an operation known as the Affine Transform applied to it. Lets go over this in depth with some
            examples.
        </p>
        <p class = "text-column">
            Previously I mentioned that multiplication in a Galois field is typically done via lookup tables rather than a multiplication function. That method
            is especially applicable to inverse multiplication in finite fields. Calculating the multiplicative inverse of a number in a finite field requires
            access to log and anti-log (exponent) tables in the same finite field. Once these tables are constructed the multiplicative inverse can be found
            using the formula anti-log(255 - log(x)). This formula works for all numbers excepting zero which must be handled as a special case; for AES 
            purposes the inverse of zero is assumed to be zero even though this breaks ordinary mathematic rules.
        </p>
        <p class = "text-column">
            Calculating log and anti-log tables for taking the multiplicative inverse of a number requires the use of exponentiation in a finite field. It
            turns out that certain numbers in the range 0 - i where i is the Galois field limit will generate all possible numbers in the field if repeatedly 
            exponentiated using Galois multiplication. Those numbers are referred to as field generators and work like this,
            <br>g = the generator number
            <br>g*1 = a
            <br>g*a = b
            <br>g*b = c
            <br>g*d = e
            <br>Eventually if the above process is repeated i times all possible numbers in the set will have been visited. By storing these numbers as they
            are generated in a loop we can produce a lookup table which will tell us the result of some exponent or logarithm of x. Below is some dart code
            demonstrating the process of generating these tables.
        </p>
        <pre class = "code-block">
void _populateLogAndAntilog() {
    int product = 1;

    for (var i = 0; i < this._fieldLimit; i++) {
        _logTable[product] = i;
        _antiLogTable[i] = product;
        product = this.galoisMultiplication(_generator, product);
    }
}

void _fillSboxWithMultiplicativeInverse() {
    // We skip i = 0 here because 0 is a special case.
    // We define the multiplicative inverse of zero to be zero.
    for (var i = 1; i < this._fieldLimit; i++) {
        this._sBox[i] = this._antiLogTable[255 - this._logTable[i]];
    }
}
        </pre>
        <p class = "text-column">
            The following is a list of all numbers which can be used as generators for the Gf(256) finite field:
        </p>
        <pre class = "code-block">
3 5 6 9 11 14 17 18 19 20 23 24 25 
26 28 30 31 33 34 35 39 40 42 44 48 
49 60 62 63 65 69 70 71 72 73 75 76 
78 79 82 84 86 87 88 89 90 91 95 
100 101 104 105 109 110 112 113 118 
119 121 122 123 126 129 132 134 135 
136 138 142 143 144 147 149 150 152 
153 155 157 160 164 165 166 167 169 
170 172 173 178 180 183 184 185 186 
190 191 192 193 196 200 201 206 207 
208 214 215 218 220 221 222 226 227 
229 230 231 233 234 235 238 240 241 
244 245 246 248 251 253 254 255
        </pre>
        <p class = "text-column">
            After filling the Sbox with multiplicative inverses in Gf(256) the next step is to compute the Affine transform for each value. 
        </p>
        <h3>Key Expansion</h3>
        <h3>Add Round Key</h3>
        <h3>Substitute Bytes</h3>
        <h3>Shift Rows</h3>
        <h3>Mix Columns</h3>
        <h3>Full Example</h3>
    </div>
</body>