<!DOCTYPE html>
<head>
<style>
    .short-divider{
        max-width: 500px;
        min-width: 100px;
        height: 1px;
        border: solid 1px black;
    }
    .text-column{
        max-width: 700px;
    }
    .code-block{
        background-color: bisque;
        max-width: 700px;
        padding: 20px;
        border: black solid 2px;
    }
    h3{
        text-decoration: underline;
    }
</style>
</head>

<body>
    <div id = "post-content">
        <h2>My Adventures with AES</h2>
        <div class = "short-divider"></div>
        <h5>My experiences writing a ground-up implementation of the Advanced Encryption Standard in Dart.</h5>
        <p class = "text-column">
            The AES is a commonly used encryption standard which was adopted by the United States Government following a NIST competition.
            Its predecessor, DES or the Digital Encryption Standard, had been shown to be vulnerable to several types of attacks and a complete
            crack of the DES cipher was considered imminent. The cipher which won the NIST competition to become the AES was the Rijndael cipher.
            Designed by two Belgian cryptographers, Vincent Rijmen and Joan Daemen, the Rijndael cipher won out over fifteen serious competitors
            which also met the NIST requirements for entry.  After being ratified by NIST it was accepted by the US Government in 2002 as a federal
            standard.
        </p>
        <br>
        <h3>A High-Level Overview</h3>
        <p class = "text-column">
            AES works by applying a repetitive process to a block of 128 bits of data. This process allows the data to be diffused sufficiently far
            from its original state as well as encrypted multiple times using multiple keys (referred to as round keys in the cipher). Typically the
            process starts by obtaining 128, 192 or 256 bits of secure random data from an SPRNG which are used as the private key of the encryption.
            The key is then subjected to a process known as key expansion where the original key is used to generate 10, 12 or 14 round keys depending
            on the length of the private key.  Once these keys are derived the actual encryption begins.
        </p>
        <p class = "text-column">
            First the private key is applied to the current block (I will go over what "applied" entails later), this comprises the complete first
            round of encryption.  Next the block undergoes three processes to diffuse the data, 1) Substitute bytes, 2) Shift rows, 3) Mix columns;
            after these three processes complete the next round key is applied and the cycle begins again. This cycle occurs a total of 9, 11 or 13
            times depending on the key size. Finally, for the last round, the substitute bytes and shift rows steps occur before the final
            round key is applied.  Note that the mix columns step is omitted in the final round.  AES processes blocks of 128 bytes at a time so once
            the first block is encrypted subsequent block are encrypted the same way.  If the total number of bits to be encrypted cannot be broken
            evenly into 128 bit blocks the last block is padded with zeros.
        </p>
        <br>
        <h3>A Few Notes</h3>
        <ol>
            <li class = "text-column">
                I am not a cryptographer, the following information is my understanding of the AES and may be incorrect. I suggest that you check this
                information against other sources if you are trying to learn about AES beyond simple curiosity.
            </li>
            <li class = "text-column">
                This post contains my code implementing AES, the code can also be found <a href = "https://github.com/ixonstater/learning_aes">here</a>
                on my github page. This code should NOT be used ANYWHERE unless you are trying to learn about AES. While the AES has never been cracked
                untested implementations can often be vulnerable to fascinating group of exploits known as side-channel attacks.
            </li>
            <li class = "text-column">
                My implementation of AES does not use a secure cipher mode, instead it uses the "default" AES encryption mode ECB or Electronic Code Book.
                I will not cover different cipher modes in depth here as they do not affect the base AES algorithm, but you should note that using an
                insecure cipher mode can also leave your information in a vulnerable state post encryption.
            </li>
        </ol>
        <br>
        <h3>Fundamental Mathematics in the AES</h3>
        <h4>Bitwise Xor</h4>
        <h4>Galois Fields</h4>
        <p class = "text-column">
            Probably the single most important set of operations in AES encryption are those involving Galois Fields. Evariste Galois, pronounced Galwaa,
            was a brilliant French mathematician who died very young after being wounded in a duel. His work in finite fields is crucial to the Rijndael
            cipher and AES. A finite field (also known as a Galois field) is a field that contains a finite (limited / constrained) number of elements. Essentially it is a series of
            integers starting at x and ending at x + i where i is the length of the field. The finite field is maintained by defining numeric operations eg.
            addition and multiplication such that any operation applied to members of the field will produce another number in the field. For example in
            Gf(5) (denoting the field {0, 1, 2, 3, 4}), 1 + 2 = 3, but 4 + 1 = 0. This type of operation should be familiar to anyone with experience
            using the modulus operator. Indeed, for any prime limit eg Gf(3), Gf(19), Gf(13), addition and multiplication can be defined as c = (a + b) % i
            or c = (a * b) % i where i is the limit of the Galois field.
        </p>
        <p class = "text-column">
            Addition and multiplication in prime Galois fields are simple enough, but what about Gf(6) or Gf(8)? As it turns out one of these will work but
            the other will not; not just any number can be chosen as the limit of a finite field without breaking the constraints on arithmetic operations. 
            The number chosen must be either a prime, or a prime power.  A prime power is a number of the form p^k where k is an arbitrary exponent and p
            is an arbitrary prime number. If these constraints are followed a finite / Galois field can be constructed, albeit with different rules involving
            multiplication and addition.
        </p>
        <p class = "text-column">
            It is helpful to understand a little about the representation of numbers in a Galois field as polynomials with coefficients in Gf(2). Remember
            that Gf(2) = {0, 1}, so the possible coefficients in our polynomial are either 0 or 1. This lets us represent any number in any Galois field
            Gf(p^k) as a polynomial where the coefficient is the binary digit occupying that space.  For example 41 = 00101001 = 0x^7 + 0x^6 + 1x^5 + 0x^4
            + 1x^3 + 0x^2 + 0x^1 + 1x^0 = x^5 + x^3 + 1. This representation may seem convoluted, but it is necessary to preform addition and multiplication
            in a prime power Galois field. Galois operations can be done with any prime base, however base 2 is most popular in computer applications because
            of the numbers binary nature.
        </p>
        <p class = "text-column">
            Addition is done by adding two numbers (represented as polynomials) from Gf(p^k) in Gf(p). For example 
            <br>41 + 10 in Gf(2)
            <br>= (x^5 + x^3 + 1) + (x^3 + x) 
            <br>= x^5 + x + 1.
            <br>Remember, we are adding in Gf(2) so 1 + 1 = 0; this is the reason that x^3 + x^3 results in 0. This is more easily understood in
            its binary representation 1010 + 101001 where addition is actually a bitwise Xor operation.
        </p>
        <p class = "text-column">
            Multiplication is more complex than addition and is done by standard polynomial multiplication followed by modular division via some irreducible polynomial which
            was used define the finite field.  Sounds hard right? It's not too bad if taken one step at a time with an example, so, for example: 12 * 7 in Gf(2^8).
            <br>12 = x^3 + x^2 (see description of number representation as polynomials in Galois fields above)
            <br>7 = x^2 + x + 1
            <br>p = (12 * 7)
            <br>p = (x^3 + x^2) * (x^2 + x + 1)
            <br>p = (x^5 + x^4 + x^3) + (x^4 + x^3 + x^2).
            <br>So far we have just done simple polynomial multiplication; in the next step, consolidating the terms, addition is done like described above, in Gf(2). Therefore
            our polynomial product 
            <br>p = x^5 + x^2 = 36.
            <br>Since this does not exceed the limit of our our field, 256, the final step of reducing modulo some
            irreducible polynomial is not necessary and our final product is 36. It is worth noting that with the reducing polynomial for AES, applying the
            modulus operation would still result in 36 being the final answer. If you want to see an example involving modulo reduction please look
            <a href = "https://en.wikipedia.org/wiki/Finite_field_arithmetic">here</a>.
        </p>
        <p class = "text-column">
            For practical application in AES multiplication is usually done via lookup in a table of values rather than via a computational process (unless
            the implementation is built in a context with very low memory availability). This method requires 512 bytes of total memory space. In addition,
            Galois multiplication in 2^8 (the field size used in AES) can be done very efficiently using a modified version of the 
            <a href = "https://en.wikipedia.org/wiki/Finite_field_arithmetic">Peasant's Algorithm</a>. Included here is a dart function which implements that
            algorithm.
        </p>
        <pre class = "code-block">
int galoisMultiplication(int a, int b) {
    int p = 0;
    int highBitSet;
    for (var i = 0; i < 8; i++) {
        if ((b & 1) == 1) {
        p ^= a;
        }
        highBitSet = (a & 0x80);
        a <<= 1;
        if (highBitSet == 0x80) {
        a ^= 0x1b;
        }
        b >>= 1;
    }

    // Convert back to unsigned 8 bit int
    return p % this._fieldLimit;
}
        </pre>
        <h4>Affine Transform</h4>
        <h3>Sbox Generation</h3>
        <h3>Key Expansion</h3>
        <h3>Add Round Key</h3>
        <h3>Substitute Bytes</h3>
        <h3>Shift Rows</h3>
        <h3>Mix Columns</h3>
        <h3>Full Example</h3>
    </div>
</body>